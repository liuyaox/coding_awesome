# HiveSQL 语法 Demo

## 集合的交集 & 并集 & 差集 & 集合判断是否相同

前提是两个集合 Schema 完全一致，不妨设集合主键是 key1 和 key2（都非空），其他字段是 col1 和 col2


### 1. 交集

方法1：使用 **left semi jon**

```sql
select t1.key1,  --select中不能有t2
    t1.key2,
    t1.col1,
    t1.col2
from table1 t1
left semi join table2 t2
on t1.key1 = t2.key1 and t1.key2 = t2.key2
```

方法2：使用 inner join，效率不如方法1

方法3： 参考 *4. 差集*

### 2. 并集-去重

- 方法1： 两集合 union

```sql
select * from table1 t1
union
select * from table2 t2
```

方法2： 参考 *4. 差集*，较方法1，代码量较多，效率呢？

### 3. 并集-不去重

方法：类似 *2. 并集-去重*，两集合 union all

### 4. 差集

方法：先 full outer join ，则 t2.key1 和 t2.key2 都是 null 的部分为 table1-table2，同理求 table2-table1

```sql
-- 先full outer join，其结果可用于求交集、并集和差集！！！
from table1 t1
full outer join table2 t2
on t1.key1 = t2.key1 and t1.key2 = t2.key2;
--以上代码块记为from_clause，下文以此代指

--差集：table1-table2
select t1.*
from_clause
where t2.key1 is null and t2.key2 is null;

--差集：table1-table2
select t2.*
from_clause
where t1.key1 is null and t1.key2 is null;

--交集
select t1.*
from_clause
where t1.key1 is not null and t1.key2 is not null
    and t2.key1 is not null and t2.key2 is not null;

--并集(去重) 方法1：table1-table2 union all table2
select t1.*
from_clause
where t2.key1 is null and t2.key2 is null
union all
select * from table2;

--并集(去重) 方法2：直接取
select cols[0] as key1,
    cols[1] as key2,
    cols[2] as col1,
    cols[3] as col2
from (
    select 
        split(case
            when t1.key1 is null and t1.key2 is null then concat('##', t2.key1, t2.key2, t2.col1, t2.col2)
            else concat('##', t1.key1, t1.key2, t1.col1, t1.col2)
        end) as cols
    from_clause
) t3;
```

表格表示如下：

| t1.key1 | t1.key2 | t2.key1 | t2.key2 | 结果 |
| :-: | :-: | :-: | :-: | :-: |
| \ | \ | null | null | t1-t2 |
| null | null | \ | \ | t2-t1 |
| not null | not null | not null | not null | 交集 |

### 5 判断两个集合是否相同

方法：借鉴差集的思想，统计两种差集各自的数据量

```sql
select sum(case when t1.key1 is null and t1.key2 is null then 1 else 0 end) as num_21,
    sum(case when t2.key1 is null and t2.key2 is null then 1 else 0 end) as num_12,
    sum(case when t1.key1 is not null and t1.key2 is not null and t2.key1 is not null and t2.key2 is not null then 1 else 0 end) as num_inter
from table1 t1
full outer join table2 t2
on t1.key1 = t2.key1 and t1.key2 = t2.key2

--更严谨的写法如下，因为t2可能本身就含有重复行(其实也可先分别对t1和t2去重，在from和join之前)，num_12和num_inter同理
--count(distinct case when t1.key1 is null and t1.key2 is null then concat('##', t2.key1, t2.key2) end) as num_21,
```

表格表示如下：

| num_21 | num_12 | num_inter | 结果 |
| :-: | :-: | :-: | :-: |
| 0 | 0 | >0 | 完全相同 |
| >0 | 0 | >0 | t1是t2真子集 |
| 0 | >0 | >0 | t2是t1真子集 |
| >0 | >0 | >0 | t1与t2有交集，又各有不同 |
| \ | \ | 0 | t1与t2无交集，完全不同 |
